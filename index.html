<!DOCTYPE html>
<html lang="zh">
<head>

    <meta charset="UTF-8">

    <title>Crystal Siege - Under The Surface</title>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: "Microsoft YaHei", Arial, sans-serif; color: #fff; }
        canvas { display: block; }
        #shopUI {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(10, 20, 30, 0.95); border: 2px solid #00bbff;
            padding: 20px; display: none; border-radius: 10px; width: 400px; z-index: 100;
        }
        #roleSelect {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000;
        }
        .item-btn, .role-btn {
            background: #1a2a35; border: 1px solid #444; color: #fff;
            padding: 15px; margin: 10px 0; cursor: pointer; display: flex; justify-content: space-between;
            transition: 0.2s; width: 300px;
        }
        .item-btn:hover, .role-btn:hover { background: #2a3a45; border-color: #00f2ff; }
        .item-btn span { color: gold; font-weight: bold; }
        h2 { text-align: center; color: #00f2ff; margin-top: 0; }
        .hint { text-align: center; font-size: 12px; color: #aaa; }
    </style>

</head>
<body>

<div id="roleSelect">
    <h2>Choose Your Position</h2>
    <div class="role-btn" onclick="pickRole('tank')">üõ°Ô∏è TANK (High HP / Melee)</div>
    <div class="role-btn" onclick="pickRole('warrior')">‚öîÔ∏è  FIGHTER (Balanced / Melee)</div>
    <div class="role-btn" onclick="pickRole('assassin')">üó°Ô∏è ASSASSIN (High Burst / Agile)</div>
    <div class="role-btn" onclick="pickRole('mage')">üîÆ MAGE (Ranged / AOE Ultimate)</div>
    <div class="role-btn" onclick="pickRole('archer')">üèπ Archer MARKSMAN (Long Range / Consistent Damage)</div>
</div>

<div id="shopUI">
    <h2>Crystal Forge (Press P to Close)</h2>
   
    <div class="item-btn" onclick="buyItem('atk')">
        Starbreaker: Attack +50 <span>$1000</span>
    </div>
   
    <div class="item-btn" onclick="buyItem('hp')">
        Titan's Heart: Max HP +500 <span>$1000</span>
    </div>
   
    <div class="item-btn" onclick="buyItem('speed')">
        Zephyr Wing: Movement & Attack Speed <span>$1000</span>
    </div>
   
    <p class="hint">You must be at the Fountain to purchase items.</p>
</div>

<canvas id="gameCanvas"></canvas>

<script>

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const shopUI = document.getElementById('shopUI');

const heroSprite = new Image();
heroSprite.src = 'data:image/png;base64,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'; // base64 Âú∞ÂùÄ

// heroes animate const
const FRAME_IDLE = 0;           // standing (Á¨¨1Â∏ß)
const FRAME_WALK_L = 1;     // left leg    (Á¨¨2Â∏ß)
const FRAME_WALK_R = 2;     // right leg (Á¨¨3Â∏ß)
const FRAME_ATTACK = 4;      // hit          (Á¨¨4Â∏ß)
const FRAME_ULT = 3;              // ultimate (Á¨¨5Â∏ß)

// animate update
function updatePlayerAnimation(p, now) {

    // first: ultimate (last for 500ms)
    if (now - (p.lastUltTime || 0) < 500) {
        p.currentFrame = FRAME_ULT;
    }
    // second: hit (last for 200ms)
    else if (now - (p.lastFire || 0) < 200) {
        p.currentFrame = FRAME_ATTACK;
    }
    // third: move (WASD)
    else if (keys['w'] || keys['a'] || keys['s'] || keys['d']) {
        // shift legs every 200ms
        p.currentFrame = (Math.floor(now / 200) % 2 === 0) ? FRAME_WALK_L : FRAME_WALK_R;
    }
    // default: standing
    else {
        p.currentFrame = FRAME_IDLE;
    }
}

const WORLD_SIZE = 4000;
const ROLES = {
    tank:    { hp: 2000, atk: 60, range: 120, speed: 400, color: '#666666', dashDist: 300, dashCD: 8000 },
    warrior: { hp: 1200, atk: 90, range: 150, speed: 450, color: '#ffffff', dashDist: 350, dashCD: 6000 },
    assassin:{ hp: 800,  atk: 150,range: 120, speed: 550, color: '#ff00ff', dashDist: 450, dashCD: 5000 },
    mage:    { hp: 700,  atk: 100,range: 400, speed: 420, color: '#00ffff', dashDist: 300, dashCD: 9000 },
    archer:  { hp: 600,  atk: 110,range: 550, speed: 430, color: '#ffff00', dashDist: 250, dashCD: 7000 }
};

const PATHS = {
    top: {
        blue: [{x: 250, y: 2500}, {x: 250, y: 250}, {x: 2000, y: 250}, {x: 3800, y: 250}],
        red: [{x: 2500, y: 250}, {x: 250, y: 250}, {x: 250, y: 2000}, {x: 250, y: 3800}]
    },
    mid: {
        blue: [{x: 1000, y: 3000}, {x: 2000, y: 2000}, {x: 3000, y: 1000}, {x: 3800, y: 200}],
        red: [{x: 3000, y: 1000}, {x: 2000, y: 2000}, {x: 1000, y: 3000}, {x: 200, y: 3800}]
    },
    bot: {
        blue: [{x: 2500, y: 3750}, {x: 3750, y: 3750}, {x: 3750, y: 2500}, {x: 3750, y: 200}],
        red: [{x: 3750, y: 1500}, {x: 3750, y: 3750}, {x: 1500, y: 3750}, {x: 200, y: 3750}]
    }
};

const brushes = [
    { x: 1000, y: 1000, w: 300, h: 150 },
    { x: 3000, y: 3000, w: 300, h: 150 },
    { x: 2000, y: 2000, w: 200, h: 200 }
];


let minions = [], towers = [], bullets = [], heroes = [], jungles = [], effects = [];
let floatingTexts = [];
let showScoreboard = false;
let killText = "", killTimer = 0, gameOver = false;
let lastUpdate = Date.now();
const camera = { x: 0, y: 0, zoom: 0.8 };
const keys = {};

let waveCount = 0;      
let isShopOpen = false;
let mouseX = 0; // x
let mouseY = 0; // y


const SHOP_ITEMS = [
    { id: 1, name: "Magic Sword", cost: 1300, atk: 40, desc: "Attack Up 40" },
    { id: 2, name: "Heal Robe", cost: 1000, hp: 350, desc: "HP Up 350" },
    { id: 3, name: "Wing Shoes", cost: 800, speed: 30, desc: "Speed Up 30" },
    { id: 4, name: "Vampire Scepter", cost: 900, atk: 15, desc: "Attack with Heal" }
];



function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.onresize = resize; resize();

function pickRole(type) {
    initHeroes(type);
    initTowers();
    initJungle();
 
    requestAnimationFrame(loop);

    setInterval(spawnMinions, 20000);
    spawnMinions();
    document.getElementById('roleSelect').style.display = 'none';
}

function initHeroes(playerRole) {
    heroes = [];
    const rolesKeys = Object.keys(ROLES);
    const lanes = ['mid', 'top', 'top', 'bot', 'bot'];
   
    for(let i=0; i<5; i++) {
        // Team Blue
        let rType = i === 0 ? playerRole : rolesKeys[i % 5];
        let attr = ROLES[rType];
        heroes.push({

isRecalling: false,  
recallEndAt: 0,        
recallMaxTime: 5000,   // recall timeÔºà5 secÔºâ

            id: 'blue_'+i, team: 'blue', isPlayer: i === 0, lane: lanes[i], role: rType,
            x: 200, y: 3800, color: i === 0 ? '#ffffff' : attr.color, radius: 25,
            hp: attr.hp, maxHp: attr.hp, atk: attr.atk, speed: attr.speed,
            range: attr.range, vision: 600, level: 1, gold: 500, kills:0, deaths:0, assists:0,
            isDead: false, lastFire: 0, atkDelay: 600, skillCD: 0, skillMaxCD: 5000,
            skill2CD: 0, skill2MaxCD: attr.dashCD || 7000, dashDist: attr.dashDist || 300
        });
        // Team Red
        let redType = rolesKeys[(i+1) % 5];
        let redAttr = ROLES[redType];
        heroes.push({
            id: 'red_'+i, team: 'red', isPlayer: false, lane: lanes[i], role: redType,
            x: 3800, y: 200, color: '#ff4444', radius: 25,
            hp: redAttr.hp, maxHp: redAttr.hp, atk: redAttr.atk, speed: redAttr.speed,
            range: redAttr.range, vision: 600, level: 1, gold: 500, kills:0, deaths:0, assists:0,
            isDead: false, lastFire: 0, pathIdx: 0, atkDelay: 800
        });
    }
}

// Main Loop
function loop() {
    update();
    render();
    if(!gameOver) requestAnimationFrame(loop);
}


window.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if (e.key === 'Tab') { e.preventDefault(); showScoreboard = true; }

    if (e.key.toLowerCase() === 'p') toggleShop();
});
window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
    if (e.key === 'Tab') showScoreboard = false;
});






// jungle system
function initJungle() {
    const junglePos = [
        {x: 800, y: 1500, type: 'BlueBuff', atk: 80}, {x: 3200, y: 2500, type: 'RedBuff', atk: 80},
        {x: 1500, y: 800, type: 'Wolf', atk: 60}, {x: 2500, y: 3200, type: 'Bird', atk: 60},
       
        {x: 1200, y: 1200, type: 'Scuttler', atk: 0, hp: 800}, {x: 2800, y: 2800, type: 'Scuttler', atk: 0, hp: 800},
       
        {x: 2000, y: 1200, type: 'Baron', atk: 300, hp: 10000, radius: 60},
        {x: 2000, y: 2800, type: 'Dragon', atk: 200, hp: 8000, radius: 50}
    ];
    junglePos.forEach(p => {
        jungles.push({
            x: p.x, y: p.y, name: p.type, team: 'neutral', hp: p.hp || 1500, maxHp: p.hp || 1500,
            atk: p.atk, radius: p.radius || 30, lastAtk: 0, isDead: false, respawnTime: 30000, deadAt: 0, range: 400
        });
    });
}

function initTowers() {
    towers = [];
    const layout = [
        [400, 3600, 'blue', 'base'], [200, 3800, 'blue', 'main'],
        [800, 3200, 'blue', 'mid'], [1300, 2700, 'blue', 'mid'],
        [250, 2800, 'blue', 'top'], [250, 1800, 'blue', 'top'],
        [1200, 3750, 'blue', 'bot'], [2200, 3750, 'blue', 'bot'],
        [3600, 400, 'red', 'base'], [3800, 200, 'red', 'main'],
        [3200, 800, 'red', 'mid'], [2700, 1300, 'red', 'mid'],
        [2800, 250, 'red', 'top'], [1800, 250, 'red', 'top'],
        [3750, 1200, 'red', 'bot'], [3750, 2200, 'red', 'bot']
    ];
    layout.forEach(d => {
        let isMain = d[3] === 'main';
        towers.push({ x: d[0], y: d[1], team: d[2], lane: d[3], hp: isMain ? 8000 : 3000, maxHp: isMain ? 8000 : 3000, range: 450, lastShot: 0, vision: 650, target: null });
    });
}

function fire(src, tar) {

    if (!tar || (tar.hp <= 0 && !tar.isDead)) return;

    let damage = src.atk;

    // positions‚Äô function
   
    // archer: higher attack when further
    if (src.role === 'archer') {
        let dist = Math.hypot(src.x - tar.x, src.y - tar.y);
        damage *= (1 + (dist / src.range) * 0.3);
    }

    // mageÔºö
    if (src.role === 'mage' && src.isPlayer) {
        src.exp += 5;
    }

    // bullets
    bullets.push({
        x: src.x,
        y: src.y,
        target: tar,
        team: src.team,
        dmg: damage,
        speed: 1000, // bullet speed
        isTowerShot: false
    });
}



function useSkill(h) {
    if (h.skillCD > 0 || h.isDead) return;

    effects.push({
        x: h.x,
        y: h.y,
        r: 10,
        maxR: h.skillRange || 300,
        life: 0.5,
        color: h.color + '44'
    });

 
    const targets = [...heroes, ...minions, ...jungles].filter(e =>
        e.team !== h.team &&

        (e.hp > 0 || !e.isDead) &&
        Math.hypot(e.x - h.x, e.y - h.y) <= (h.skillRange || 300)
    );

    targets.forEach(tar => {
        applyDamage(h, tar, h.skillDmg || 200);
    });

 
    h.skillCD = h.skillMaxCD;
    if (h.isPlayer) h.isRecalling = false;
}



function useDash(h) {
    if (h.skill2CD > 0 || h.isDead) return;

    let dx = 0, dy = 0;
    if (keys['w']) dy -= 1;
    if (keys['s']) dy += 1;
    if (keys['a']) dx -= 1;
    if (keys['d']) dx += 1;

    if (dx === 0 && dy === 0) return;

    let angle = Math.atan2(dy, dx);
   
    let newX = h.x + Math.cos(angle) * (h.dashDist || 300);
    let newY = h.y + Math.sin(angle) * (h.dashDist || 300);

    // limitation
  h.x = Math.max(h.radius, Math.min(WORLD_SIZE - h.radius, newX));
    h.y = Math.max(h.radius, Math.min(WORLD_SIZE - h.radius, newY));


        if (window.effects) {
        effects.push({ x: h.x, y: h.y, r: 40, maxR: 100, life: 0.2, color: 'rgba(255,255,255,0.5)' });
    }

    h.skill2CD = h.skill2MaxCD;
    h.isRecalling = false;
}


function applyDamage(attacker, victim, dmg) {
   
    if (!victim || victim.hp <= 0 || victim.isDead) return;

   
    victim.hp -= dmg;

    // hit particle effect
    const isHero = heroes.includes(victim);
    const isJungle = typeof jungles !== 'undefined' && jungles.includes(victim);

    if (isHero || isJungle) {
       
        let particleCount = (attacker && attacker.isPlayer) ? 20 : 10;
        for (let i = 0; i < particleCount; i++) {
            effects.push({
                type: 'hitParticle',
                x: victim.x,
                y: victim.y,
               
                vx: (Math.random() - 0.5) * 300,
                vy: (Math.random() - 0.5) * 300 - 100,
                life: 0.4,
                maxLife: 0.4,
               
                color: isHero ? 'rgba(255, 215, 0, 0.9)' : 'rgba(255, 100, 0, 0.9)',
                radius: Math.random() * 3 + 1
            });
        }
    }

   
    if (attacker && !attacker.isDead) {
     
        if (attacker.role === 'warrior') {
            attacker.hp = Math.min(attacker.maxHp, attacker.hp + attacker.maxHp * 0.02);
        }
    }


    if (victim.isPlayer) {
        victim.isRecalling = false;
    }


    if (victim.hp <= 0) {
        victim.hp = 0;

       
        if (isHero) {
            if (!victim.isDead) {
                victim.isDead = true;
               
                victim.respawnAt = Date.now() + (10000 + (victim.level || 1) * 1000);
               
                if (attacker) {
                    attacker.gold += 300;
                    if (typeof gainExp === 'function') gainExp(attacker, 500);
                    if (attacker.isPlayer) {
                        killText = "ENEMY SLAIN!";
                        killTimer = 120;
                    }
                }
            }
        }
       
        else if (minions.includes(victim)) {
            if (attacker) {
               
                if (attacker.isPlayer) {
                    attacker.gold += 60;
                    killText = "LAST HIT +$60";
                    killTimer = 40;
                } else {
                    attacker.gold += 20;
                }
                if (typeof gainExp === 'function') gainExp(attacker, 40);
            }
           
            minions = minions.filter(m => m !== victim);
        }
       
        else if (isJungle) {
            victim.isDead = true;
            victim.deadAt = Date.now();
            if (attacker) {
                attacker.gold += 150;
                if (typeof gainExp === 'function') gainExp(attacker, 150);
            }
        }
       
        else if (towers.includes(victim)) {
            if (victim.lane === 'main') {
                gameOver = true;
                killText = victim.team === 'red' ? "VICTORY!" : "DEFEAT!";
                killTimer = 9999;
            }
            victim.hp = 0;
        }
    }
}




function gainExp(hero, amount) {
    if (!hero || hero.level >= 18) return;
    hero.exp += amount;
    let nextLevelExp = hero.level * 200 + 100;
    if (hero.exp >= nextLevelExp) {
        hero.level++; hero.exp = 0;
        hero.maxHp += 150; hero.hp = hero.maxHp;
        hero.atk += 15;
        if (hero.isPlayer) { killText = "LEVEL UP!"; killTimer = 60; }
    }
}

function checkTowerAggro(attacker, victim) {
    towers.forEach(t => { if (t.team === victim.team && t.hp > 0 && Math.hypot(t.x - attacker.x, t.y - attacker.y) <= t.range) t.target = attacker; });
}

function isVisibleToBlue(target) {
    if (target.team === 'blue') return true;

    // check target
    let targetInBrush = brushes.find(b =>
        target.x > b.x && target.x < b.x + b.w &&
        target.y > b.y && target.y < b.y + b.h
    );

    const allies = [
        ...heroes.filter(h => h.team === 'blue' && !h.isDead),
        ...minions.filter(m => m.team === 'blue'),
        ...towers.filter(t => t.team === 'blue' && t.hp > 0)
    ];

    return allies.some(a => {
        let dist = Math.hypot(a.x - target.x, a.y - target.y);
        if (dist > a.vision) return false;

        if (targetInBrush) {
           
            let observerInSameBrush = (
                a.x > targetInBrush.x && a.x < targetInBrush.x + targetInBrush.w &&
                a.y > targetInBrush.y && a.y < targetInBrush.y + targetInBrush.h
            );
            return observerInSameBrush;
        }
       
        return true;
    });
}


function isVisibleToRed(target) {
    if (target.team === 'red') return true;

   
    let targetInBrush = brushes.find(b =>
        target.x > b.x && target.x < b.x + b.w &&
        target.y > b.y && target.y < b.y + b.h
    );

    const redAllies = [
        ...heroes.filter(h => h.team === 'red' && !h.isDead),
        ...minions.filter(m => m.team === 'red'),
        ...towers.filter(t => t.team === 'red' && t.hp > 0)
    ];

    return redAllies.some(a => {
        let dist = Math.hypot(a.x - target.x, a.y - target.y);
        if (dist > (a.vision || 600)) return false;

        if (targetInBrush) {
           
            let observerInSameBrush = (
                a.x > targetInBrush.x && a.x < targetInBrush.x + targetInBrush.w &&
                a.y > targetInBrush.y && a.y < targetInBrush.y + targetInBrush.h
            );
            return observerInSameBrush;
        }
        return true;
    });
}



function useUltimate() {
    const p = heroes.find(h => h.isPlayer);
   
    if (!p || p.isDead || p.skillCD > 0) return;


    if (typeof screenShake !== 'undefined') screenShake = 40;


    effects.push({
        type: 'beneathSurface',
        x: p.x,
        y: p.y,
        r: 30,
        maxR: 300,  
        life: 1.0,
        color: '#c0d9d9'
    });

   
    let config = { color: '#ffffff', particleCount: 30, range: 400, damage: 300 };

    if (p.role === 'mage') {
        config = { color: '#a000ff', particleCount: 50, range: 600, damage: 500 };
    } else if (p.role === 'tank') {
        config = { color: '#888888', particleCount: 40, range: 500, damage: 250 };
    } else if (p.role === 'warrior') {
        config = { color: '#ffffff', particleCount: 35, range: 450, damage: 400 };
    } else if (p.role === 'assassin') {
        config = { color: '#ff00ff', particleCount: 60, range: 350, damage: 600 };
    } else if (p.role === 'archer') {
        config = { color: '#ffff00', particleCount: 40, range: 700, damage: 350 };
    }

   
    effects.push({
        type: 'pulse',
        x: p.x, y: p.y,
        r: 20,
        maxR: config.range,
        life: 1.0,
        color: config.color
    });

   
    for(let i=0; i < config.particleCount; i++) {
        effects.push({
            type: 'hitParticle',
            x: p.x, y: p.y,
            vx: (Math.random() - 0.5) * 500,
            vy: (Math.random() - 0.5) * 500,
            radius: Math.random() * 5 + 2,
            color: config.color,
            life: 1.0
        });
    }

   
    [...minions, ...heroes, ...jungles].forEach(target => {
        if (target.team !== p.team && !target.isDead && target.hp > 0) {
            let dist = Math.hypot(target.x - p.x, target.y - p.y);
            if (dist < config.range) {
                applyDamage(p, target, config.damage);
            }
        }
    });

    p.skillCD = p.skillMaxCD;
    killText = p.role.toUpperCase() + " ULTIMATE!";
    killTimer = 100;
}


function update() {
    if (gameOver) return;
    const now = Date.now();
    const dt = (now - lastUpdate) / 1000;
    lastUpdate = now;

   
    jungles.forEach(j => {
        if(j.isDead && now - j.deadAt > j.respawnTime) {
            j.isDead = false;
            j.hp = j.maxHp;
        }
        if(!j.isDead && j.atk > 0) {
            let targetHero = heroes.find(h => !h.isDead && Math.hypot(h.x - j.x, h.y - j.y) <= j.range);
            if(targetHero && now - j.lastAtk > 1500) {
               
                bullets.push({x: j.x, y: j.y, target: targetHero, team: 'neutral', dmg: j.atk, owner: j});
                j.lastAtk = now;
            }
        }
    });

   
    heroes.forEach(h => {
        if (h.x < h.radius) h.x = h.radius;
        if (h.x > WORLD_SIZE - h.radius) h.x = WORLD_SIZE - h.radius;
        if (h.y < h.radius) h.y = h.radius;
        if (h.y > WORLD_SIZE - h.radius) h.y = WORLD_SIZE - h.radius;
    });
   
    minions.forEach(m => {
        if (m.x < m.radius) m.x = m.radius;
        if (m.x > WORLD_SIZE - m.radius) m.x = WORLD_SIZE - m.radius;
        if (m.y < m.radius) m.y = m.radius;
        if (m.y > WORLD_SIZE - m.radius) m.y = WORLD_SIZE - m.radius;
    });

   
    const p = heroes.find(h => h.isPlayer);
    heroes.forEach(h => {
       
        if (!h.isDead) {
            let pGold = 2 * dt;
            h.gold += pGold;
            h.totalGold = (h.totalGold || 0) + pGold;
        }

        // colding time
        if (h.skillCD > 0) h.skillCD = Math.max(0, h.skillCD - dt * 1000);
        if (h.skill2CD > 0) h.skill2CD = Math.max(0, h.skill2CD - dt * 1000);

       
        if (!h.isDead && h.hp <= 0) {
            h.isDead = true;
            h.deaths = (h.deaths || 0) + 1;            
            h.respawnAt = now + 10000;
           
           
            if (h.lastAttacker) {
                let killer = h.lastAttacker;
               
                if (killer.kills !== undefined) {
                    killer.kills++;
                    let reward = 300;
                    killer.gold += reward;
                    killer.totalGold = (killer.totalGold || 0) + reward;

                 
                    if (p) {
                        killText = killer.isPlayer ? "YOU HAVE SLAIN AN ENEMY!" :
                                   (killer.team === p.team ? "AN ALLY HAS BEEN SLAIN!" : "AN ENEMY HAS BEEN SLAIN!");
                        killTimer = 180;
                    }
                }
            }
        }

        if (h.isDead) {
            if (now >= h.respawnAt) {
                h.isDead = false; h.hp = h.maxHp;
                h.x = h.team === 'blue' ? 200 : 3800;
                h.y = h.team === 'blue' ? 3800 : 200;
            }
            return;
        }

       
        if (h.role === 'tank') {
            h.speed = h.hp < h.maxHp * 0.35 ? 350 : 220;
        }
        if (h.role === 'assassin') {
            let inBush = brushes.some(b => h.x > b.x && h.x < b.x + b.w && h.y > b.y && h.y < b.y + b.h);
            h.opacity = inBush ? 0.4 : 1.0;
            h.speed = inBush ? 380 : 300;
        }

       
        if (h.isPlayer) {
            if (keys['l']) {
                useUltimate();
            }

            if (keys['i']) useDash(h);
            if (keys['b'] && !h.isRecalling) { h.isRecalling = true; h.recallEndAt = now + h.recallMaxTime; }
           
            if (h.isRecalling) {
                if (keys['w'] || keys['s'] || keys['a'] || keys['d'] || keys['j'] || keys['k'] || keys['l'] || keys['i']) h.isRecalling = false;
                if (now >= h.recallEndAt) {
                    h.isRecalling = false;
                    h.x = h.team === 'blue' ? 200 : 3800;
                    h.y = h.team === 'blue' ? 3800 : 200;
                    h.hp = h.maxHp;
                }
            } else {
                let mD = h.speed * dt;
                if (keys['w']) h.y -= mD; if (keys['s']) h.y += mD;
                if (keys['a']) h.x -= mD; if (keys['d']) h.x += mD;
            }

           
            if (!h.isRecalling && now - h.lastFire > h.atkDelay) {
                if (keys['k']) {
                    let target = [...heroes, ...minions, ...jungles].find(e =>
                        e.team !== h.team && (e.hp > 0 || !e.isDead) &&
                        Math.hypot(e.x - h.x, e.y - h.y) <= h.range && isVisibleToBlue(e)
                    );
                    if (target) {
                        fire(h, target);
                        h.lastFire = now;
                        if(heroes.includes(target)) checkTowerAggro(h, target);
                    }
                }
                if (keys['j']) {
                    let tTar = towers.find(t => t.team !== h.team && t.hp > 0 && Math.hypot(t.x-h.x, t.y-h.y) <= h.range);
                    if (tTar) { fire(h, tTar); h.lastFire = now; }
                }
            }
        } else {
            updateHeroAI(h, dt, now);
        }
       
       
        let homeX = h.team === 'blue' ? 200 : 3800;
        let homeY = h.team === 'blue' ? 3800 : 200;
        if (Math.hypot(h.x - homeX, h.y - homeY) < 400) h.hp = Math.min(h.maxHp, h.hp + 200 * dt);
    });

   
    handleMinionAI(dt, now);
    handleTowerAI(now);
    handleProjectiles(dt);

   [...heroes, ...minions, ...towers].forEach(u => {
   
    if (u.displayHp === undefined) u.displayHp = u.hp;
   
   
    if (u.displayHp > u.hp) {
     
        u.displayHp -= (u.displayHp - u.hp) * 0.1;
        if (u.displayHp - u.hp < 1) u.displayHp = u.hp;
    } else if (u.displayHp < u.hp) {
       
        u.displayHp = u.hp;
    }
});




   
    for (let i = effects.length - 1; i >= 0; i--) {
        let ef = effects[i];
        if (ef.type === 'hitParticle') {
            ef.x += (ef.vx || 0) * dt;
            ef.y += (ef.vy || 0) * dt;
            ef.vy = (ef.vy || 0) + 400 * dt;
            ef.vx = (ef.vx || 0) * 0.95;
            ef.vy *= 0.95;
            ef.life -= dt;
        } else {
            ef.life -= dt * 2;
            let growSpeed = ef.maxR ? (ef.maxR / 0.5) : 200;
            ef.r += growSpeed * dt;
        }
        if (ef.life <= 0) effects.splice(i, 1);
    }

   
    if (killTimer > 0) killTimer--;
   
    if (p) {
        camera.x = p.x - (canvas.width / 2) / camera.zoom;
        camera.y = p.y - (canvas.height / 2) / camera.zoom;
       
        showScoreboard = keys['tab'];
    }
} // function update ends



function handleTowerAI(now) {
towers.forEach(t => {
if(t.hp <= 0) return; if (t.target && (t.target.isDead || t.target.hp <= 0 || Math.hypot(t.x - t.target.x, t.y - t.target.y) > t.range)) t.target = null; if (!t.target) {
let em = minions.find(m => m.team !== t.team && Math.hypot(m.x-t.x, m.y-t.y) <= t.range); let eh = heroes.find(h => h.team !== t.team && !h.isDead && Math.hypot(h.x-t.x, h.y-t.y) <= t.range); t.target = em || eh; }
if(t.target && now - t.lastShot > 1000) { bullets.push({x: t.x, y: t.y, target: t.target, team: t.team, dmg: 180, isTowerShot: true}); t.lastShot = now; }
});
}


function handleProjectiles(dt) {
    for(let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
       
        if (!b.target || (b.target.hp <= 0 && !heroes.includes(b.target))) {
            bullets.splice(i, 1);
            continue;
        }

        let dist = Math.hypot(b.target.x - b.x, b.target.y - b.y);
        let moveDist = 1200 * dt;

        if(dist < moveDist + 10) {
            let killer = heroes.find(h => h.team === b.team && !h.isDead);
            applyDamage(killer, b.target, b.dmg);
            bullets.splice(i, 1);
        } else {
            let a = Math.atan2(b.target.y - b.y, b.target.x - b.x);
            b.x += Math.cos(a) * moveDist;
            b.y += Math.sin(a) * moveDist;
        }
    }
}



function spawnMinions() {
    if (gameOver) return;
    waveCount++;

    const lanes = ['top', 'mid', 'bot'];
    let currentMaxHp = 1000 + (Math.floor(waveCount / 2) * 150);
    let currentAtk = 35 + (waveCount * 3);

    lanes.forEach(lane => {
       
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                minions.push({
                    team: 'blue', lane: lane,
                    x: 250, y: 3750,
                    hp: currentMaxHp,
                    maxHp: currentMaxHp,
                    displayHp: currentMaxHp,
                    atk: currentAtk, speed: 180, radius: 15,
                    pathIdx: 0,
                    reverse: false,
                    lastAtk: 0
                });
            }, i * 1000);
        }

     
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                const lanePath = PATHS[lane].red || PATHS[lane].blue;
                minions.push({
                    team: 'red', lane: lane,
                    x: 3750, y: 250,
                    hp: currentMaxHp,
                    maxHp: currentMaxHp,
                    displayHp: currentMaxHp,
                    atk: currentAtk, speed: 180, radius: 15,
                    pathIdx: lanePath.length - 1,
                    reverse: true,
                    lastAtk: 0
                });
            }, i * 1000);
        }
    });
}



function handleMinionAI(dt, now) {
    minions.forEach(m => {
        if (m.hp <= 0) return;

        let searchDist = 300;   // search radius
        let targets = [...minions, ...heroes, ...towers].filter(e =>
            e.team !== m.team &&
            (e.hp > 0) &&
            Math.hypot(e.x - m.x, e.y - m.y) <= searchDist
        );
       
       
        targets.sort((a, b) => {
            let typeA = minions.includes(a) ? 0 : (heroes.includes(a) ? 1 : 2);
            let typeB = minions.includes(b) ? 0 : (heroes.includes(b) ? 1 : 2);
            return typeA - typeB;
        });

        let target = targets[0];

       
        if (target) {
            let dist = Math.hypot(target.x - m.x, target.y - m.y);
            let attackRange = 150;

            if (dist <= attackRange) {
               
                if (now - (m.lastAtk || 0) > 1200) {
                    if (typeof fire === 'function') fire(m, target);
                    m.lastAtk = now;
                }
            } else {
               
                let a = Math.atan2(target.y - m.y, target.x - m.x);
                m.x += Math.cos(a) * m.speed * dt;
                m.y += Math.sin(a) * m.speed * dt;
            }
        } else {
           
            const lanePath = PATHS[m.lane][m.team] || PATHS[m.lane].blue;
            let targetPoint = lanePath[m.pathIdx];

            if (targetPoint) {
                let distToPoint = Math.hypot(targetPoint.x - m.x, targetPoint.y - m.y);
               
               
                if (distToPoint < 80) {
                    if (m.pathIdx < lanePath.length - 1) {
                        m.pathIdx++;
                    }
                }

               
                let a = Math.atan2(targetPoint.y - m.y, targetPoint.x - m.x);
                m.x += Math.cos(a) * m.speed * dt;
                m.y += Math.sin(a) * m.speed * dt;
            }
        }
    });
}


function updateHeroAI(h, dt, now) {
    let homeX = h.team === 'blue' ? 200 : 3800;
    let homeY = h.team === 'blue' ? 3800 : 200;
   

    if (h.hp < h.maxHp * 0.3) {
        let a = Math.atan2(homeY - h.y, homeX - h.x);
        h.x += Math.cos(a) * h.speed * dt;
        h.y += Math.sin(a) * h.speed * dt;
        if (Math.hypot(h.x-homeX, h.y-homeY) < 100) h.hp = h.maxHp;
        return;
    }

    let searchDist = h.range + 200;
    let target = [...heroes, ...minions, ...towers].find(e =>
        e.team !== h.team && (e.hp > 0 || !e.isDead) &&
        Math.hypot(e.x - h.x, e.y - h.y) <= searchDist &&
        (h.team === 'red' ? isVisibleToRed(e) : isVisibleToBlue(e))
    );

    if (target) {
        let dist = Math.hypot(target.x - h.x, target.y - h.y);
        if (dist <= h.range) {
            if (now - h.lastFire > h.atkDelay) {
                fire(h, target);
                h.lastFire = now;
            }
        } else {
            let a = Math.atan2(target.y - h.y, target.x - h.x);
            h.x += Math.cos(a) * h.speed * 0.8 * dt;
            h.y += Math.sin(a) * h.speed * 0.8 * dt;
        }
    } else {
   
        let p = PATHS[h.lane][h.team];
        if (h.pathIdx === undefined) h.pathIdx = 0;
        let stage = p[h.pathIdx];

        if (Math.hypot(h.x - stage.x, h.y - stage.y) < 150) {
            if (h.pathIdx < p.length - 1) h.pathIdx++;
        }

        let a = Math.atan2(stage.y - h.y, stage.x - h.x);
        h.x += Math.cos(a) * (h.speed * 0.7) * dt;
        h.y += Math.sin(a) * (h.speed * 0.7) * dt;
    }
}









function spawnMinions() {
    if (gameOver) return;
    waveCount++;

   
    let currentMaxHp = 1000 + (Math.floor(waveCount / 2) * 150);
 
    let currentAtk = 35 + (waveCount * 3);

    ['top', 'mid', 'bot'].forEach(lane => {
        for(let i=0; i<3; i++) {
            setTimeout(() => {
               
                minions.push({
                    x: 200, y: 3800, team: 'blue', lane, pathIdx: 0,
                    hp: currentMaxHp, maxHp: currentMaxHp,
                    atk: currentAtk, lastAtk: 0, vision: 400,
                    speed: 180
                });
                // Á∫¢ÈòüÂ∞èÂÖµ
                minions.push({
                    x: 3800, y: 200, team: 'red', lane, pathIdx: 0,
                    hp: currentMaxHp, maxHp: currentMaxHp,
                    atk: currentAtk, lastAtk: 0, vision: 400,
                    speed: 180
                });
            }, i * 1000);
        }
    });
}


function toggleShop() {
    const p = heroes.find(h => h.isPlayer);
    if (!p) return;

   
    const homeX = p.team === 'blue' ? 200 : 3800;
    const homeY = p.team === 'blue' ? 3800 : 200;
    const dist = Math.hypot(p.x - homeX, p.y - homeY);

    if (dist < 500) {
        isShopOpen = !isShopOpen;
        console.log("shop is" + (isShopOpen ? "opened" : "closed"));
    } else {
       
        console.log("Too far, please go back to home and buyÔºÅ");
    }
}


function drawHPBar(x, y, w, h, hp, maxHp, displayHp, teamOrColor) {
    if (hp <= 0) return;

    let dHp = (displayHp !== undefined) ? displayHp : hp;
   
 
    ctx.fillStyle = '#000000';
    ctx.fillRect(x, y, w, h);

   
    if (dHp > hp) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(x, y, (dHp / maxHp) * w, h);
    }


    let barColor = '#00bbff';
   
    if (String(teamOrColor).startsWith('#')) {
        barColor = teamOrColor;
    } else {
       
        let team = String(teamOrColor).toLowerCase().trim();
        if (team === 'blue') barColor = '#00ff44';
        if (team === 'red') barColor = '#ff4444';
    }

    ctx.fillStyle = barColor;
    let currentWidth = (hp / maxHp) * w;
    ctx.fillRect(x, y, Math.max(0, currentWidth), h);

   
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
    ctx.lineWidth = 1;
    for (let i = 200; i < maxHp; i += 200) {
        let lx = x + (i / maxHp) * w;
        ctx.beginPath(); ctx.moveTo(lx, y); ctx.lineTo(lx, y + h); ctx.stroke();
    }

   
    ctx.strokeStyle = '#000000';
    ctx.strokeRect(x, y, w, h);
}





function isVisibleToBlue(obj) {
    if (obj.team === 'blue') return true;
    const blueUnits = [...heroes, ...minions, ...towers].filter(u => u.team === 'blue' && u.hp > 0);
    return blueUnits.some(u => Math.hypot(u.x - obj.x, u.y - obj.y) < (u.vision || 600));
}





let screenShake = 0;
function shake(amount) { screenShake = amount; }

function createSkillPulse(x, y, radius, color) {
    effects.push({
        type: 'pulse',
        x: x, y: y,
        r: 10,      
        maxR: radius,
        life: 1.0,  
        color: color,
        update(dt) {
            this.r += (this.maxR - this.r) * 5 * dt;
            this.life -= 1.5 * dt;
        }
    });
}




function updatePlayerAnimation(p, now) {
   
    if (now - (p.lastUltTime || 0) < 500) {
        p.currentFrame = FRAME_ULT;
    }
 
    else if (now - (p.lastFire || 0) < 200) {
        p.currentFrame = FRAME_ATTACK;
    }
   
    else if (keys['w'] || keys['a'] || keys['s'] || keys['d']) {
       
        p.currentFrame = (Math.floor(now / 200) % 2 === 0) ? FRAME_WALK_L : FRAME_WALK_R;
    }
   
    else {
        p.currentFrame = FRAME_IDLE;
    }
}



function render() {
    const p = heroes.find(h => h.isPlayer);
    if (!p) return;
    const now = Date.now();

   
    ctx.filter = p.isDead ? 'grayscale(100%) brightness(40%)' : 'none';
    ctx.fillStyle = '#0a141a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);



   
    let shakeX = (Math.random() - 0.5) * screenShake;
    let shakeY = (Math.random() - 0.5) * screenShake;

   
    ctx.save();
    ctx.scale(camera.zoom, camera.zoom);
 
    ctx.translate(-camera.x + shakeX, -camera.y + shakeY);

 
    ctx.strokeStyle = '#1a2a35'; ctx.lineWidth = 150; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(250, 3750); ctx.lineTo(250, 250); ctx.lineTo(3800, 250); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(250, 3750); ctx.lineTo(3750, 3750); ctx.lineTo(3750, 250); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(250, 3750); ctx.lineTo(3750, 250); ctx.stroke();


    ctx.save();
    ctx.strokeStyle = '#0F52BA';
    ctx.lineWidth = 40;          
    ctx.strokeRect(0, 0, WORLD_SIZE, WORLD_SIZE);
   
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#0F52BA';
    ctx.strokeRect(0, 0, WORLD_SIZE, WORLD_SIZE);
    ctx.restore();


   

    ctx.strokeStyle = '#002244'; ctx.lineWidth = 200;
    ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(4000, 4000); ctx.stroke();

   
    towers.forEach(t => {

if (t.target && t.hp > 0) {
    ctx.beginPath();
    ctx.moveTo(t.x, t.y);
    ctx.lineTo(t.target.x, t.target.y);
    ctx.strokeStyle = t.team === 'blue' ? 'cyan' : 'orange';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.stroke();
    ctx.setLineDash([]);
}
        if (t.hp <= 0) return;
        let dist = Math.hypot(t.x - p.x, t.y - p.y);
        ctx.beginPath(); ctx.arc(t.x, t.y, t.range, 0, Math.PI * 2);
        if (t.team === p.team) {
            ctx.strokeStyle = 'rgba(0, 187, 255, 0.3)'; ctx.lineWidth = 2; ctx.setLineDash([10, 10]); ctx.stroke(); ctx.setLineDash([]);
        } else {
            if (dist < t.range + 200 || t.target === p) {
                ctx.strokeStyle = t.target === p ? 'rgba(255, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.15)';
                ctx.lineWidth = t.target === p ? 4 : 2; ctx.setLineDash([15, 10]); ctx.stroke(); ctx.setLineDash([]);
            }
        }
        ctx.fillStyle = t.team === 'red' ? '#c21111' : '#0254b3';
        let s = t.lane === 'main' ? 100 : 70;
        ctx.fillRect(t.x - s/2, t.y - s/2, s, s);
        drawHPBar(
        t.x - 40,
        t.y - (t.lane === 'main' ? 75 : 60),
        80, 8,
        t.hp,
        t.maxHp,
        t.displayHp,
        t.team === 'blue' ? '#87d3f8' : '#f97670'      );

    });

    brushes.forEach(b => {
        let grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
        grad.addColorStop(0, 'rgba(34, 139, 34, 0.8)');
        grad.addColorStop(1, 'rgba(20, 60, 20, 0.9)');
        ctx.fillStyle = grad;
        ctx.shadowBlur = 15; ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.beginPath(); ctx.roundRect(b.x, b.y, b.w, b.h, 15); ctx.fill();
        ctx.shadowBlur = 0;
    });

    jungles.forEach(j => {
        if (j.isDead) return;
        ctx.fillStyle = j.name === 'Scuttler' ? '#00ffcc' : (j.name === 'Baron' || j.name === 'Dragon' ? '#de6a6a' : '#296880');
        ctx.beginPath(); ctx.arc(j.x, j.y, j.radius, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = "bold 14px Arial"; ctx.fillText(j.name, j.x - 25, j.y + 5);

        drawHPBar(
        j.x - j.radius,
        j.y - j.radius - 15,
        j.radius * 2,
        6,
        j.hp,
        j.maxHp,
        j.displayHp || j.hp,
        '#ffaa00'          
    );

    });


minions.concat(heroes).forEach(obj => {
   
    if (obj.isDead || obj.hp <= 0) return;

 
    if (obj.team === 'red' && !isVisibleToBlue(obj)) return;

   
    drawHPBar(
        obj.x - 25,
        obj.y - 45,
        50, 6,
        obj.hp,
        obj.maxHp,
        obj.displayHp || obj.hp,
        obj.team
    );

   
    if (obj.range) {
        ctx.beginPath();
        ctx.arc(obj.x, obj.y, obj.range, 0, Math.PI * 2);
        ctx.strokeStyle = obj.isPlayer ? 'rgba(255,255,255,0.5)' : (obj.team==='blue'?'rgba(0,242,255,0.3)':'rgba(255,68,68,0.3)');
        ctx.lineWidth = 1;
        ctx.stroke();
    }

   
    ctx.save();
    ctx.globalAlpha = obj.opacity || 1.0;

   if (obj.isPlayer) {

       
        updatePlayerAnimation(obj, now);


        const frameSize = 80;  
        const drawSize = 120;  

        ctx.translate(obj.x, obj.y);

        if (mouseX + (camera.x || 0) < obj.x) {

            ctx.scale(-1, 1);

        }


        ctx.drawImage(

            heroSprite,
            (obj.currentFrame || 0) * frameSize, 0,
            frameSize, frameSize,
            -drawSize / 2, -drawSize / 2,
            drawSize, drawSize

        );

    } else {
        ctx.fillStyle = obj.color || (obj.team === 'blue' ? '#00d2ff' : '#ff4444');
        if (obj.level) {

            ctx.shadowBlur = 10;
            ctx.shadowColor = ctx.fillStyle;

        } else {

            ctx.shadowBlur = 0;
        }

       

        ctx.beginPath();
        ctx.arc(obj.x, obj.y, obj.radius || 18, 0, Math.PI * 2);
        ctx.fill();

    }

   
    ctx.restore();


    if (obj.level) {
        ctx.fillStyle = "white";
        ctx.font = "bold 12px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Lv." + obj.level, obj.x, obj.y - 55);
    }
});



effects.forEach((ef, index) => {
    ctx.save();
   
    const effectDt = 0.016;

    if (ef.type === 'pulse') {
        ef.r += (ef.maxR - ef.r) * 0.1;
        ef.life -= 0.02;
        ctx.beginPath();
        ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI * 2);
        ctx.strokeStyle = ef.color;
        ctx.lineWidth = 10;
        ctx.globalAlpha = Math.max(0, ef.life);
        ctx.stroke();
    }
    else if (ef.type === 'hitParticle') {
       
        ef.x += (ef.vx || 0) * effectDt;
        ef.y += (ef.vy || 0) * effectDt;
        ef.vy += 10;
        ef.life -= 0.02;

        ctx.beginPath();
        ctx.arc(ef.x, ef.y, ef.radius || 4, 0, Math.PI * 2);
        ctx.fillStyle = ef.color;
        ctx.globalAlpha = Math.max(0, ef.life);
        ctx.fill();
       
        ctx.shadowBlur = 10;
        ctx.shadowColor = ef.color;
    }


if (ef.type === 'beneathSurface') {
    ctx.save();
   
   
    let grad = ctx.createRadialGradient(ef.x, ef.y, 0, ef.x, ef.y, ef.r);
    grad.addColorStop(0, `rgba(10, 0, 20, ${ef.life})`);  
    grad.addColorStop(0.5, `rgba(0, 0, 200, ${ef.life * 0.8})`);
    grad.addColorStop(1, `rgba(0, 0, 0, 0)`);          

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(ef.x, ef.y, ef.r, 0, Math.PI * 2);
    ctx.fill();


    ctx.strokeStyle = '#0F52BA';
    ctx.lineWidth = 5;
    ctx.globalAlpha = ef.life;
    for (let i = 0; i < 6; i++) {
        let angle = (i / 6) * Math.PI * 2 + (ef.r * 0.02);
        ctx.beginPath();
        ctx.moveTo(ef.x, ef.y);
        ctx.lineTo(
            ef.x + Math.cos(angle) * ef.r * 1.2,
            ef.y + Math.sin(angle) * ef.r * 1.2
        );
        ctx.stroke();
    }


    ef.r += (ef.maxR - ef.r) * 0.1;
    ef.life -= 0.015;

    ctx.restore();
}





    ctx.restore();

    if (ef.life <= 0) effects.splice(index, 1);
});



    bullets.forEach(b => {
        ctx.fillStyle = b.isTowerShot ? '#ffaa00' : 'yellow';
        ctx.beginPath(); ctx.arc(b.x, b.y, b.isTowerShot ? 10 : 6, 0, Math.PI * 2); ctx.fill();
    });

    ctx.restore();


    drawUI(now);
    if (showScoreboard) drawScoreboardUI();
    if (isShopOpen) drawShopUI();


    floatingTexts.forEach((ft, index) => {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = Math.max(0, ft.alpha);
        ctx.fillStyle = ft.color;
        ctx.font = "bold 35px Arial";
        ctx.textAlign = "center";
     
        ctx.shadowBlur = 5;
        ctx.shadowColor = "black";
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.restore();

     
        ft.y -= 1.5;      
        ft.alpha -= 0.015;
        ft.life--;

        if (ft.life <= 0 || ft.alpha <= 0) {
            floatingTexts.splice(index, 1);
        }
    });

    if (screenShake > 0) screenShake *= 0.9;
}


function drawShopUI() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
   
 
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const shopW = 600, shopH = 500;
    const shopX = (canvas.width - shopW) / 2;
    const shopY = (canvas.height - shopH) / 2;
   
    ctx.fillStyle = '#1a2a35';
    ctx.strokeStyle = '#c8aa6e';
    ctx.lineWidth = 4;
    ctx.fillRect(shopX, shopY, shopW, shopH);
    ctx.strokeRect(shopX, shopY, shopW, shopH);

    SHOP_ITEMS.forEach((item, i) => {
     
        const col = i % 2;
        const row = Math.floor(i / 2);
        const btnW = 260, btnH = 80;
        const gap = 20;
        const x = shopX + gap + col * (btnW + gap);
        const y = shopY + 80 + row * (btnH + gap);

   
        const isHover = (mouseX > x && mouseX < x + btnW && mouseY > y && mouseY < y + btnH);
        const p = heroes.find(h => h.isPlayer);
        const canAfford = p.gold >= item.cost;

       
        ctx.fillStyle = isHover ? '#2a3a45' : '#0d161d';
        ctx.strokeStyle = isHover ? '#fff' : (canAfford ? '#c8aa6e' : '#444');
        ctx.lineWidth = isHover ? 3 : 1;
       
        ctx.fillRect(x, y, btnW, btnH);
        ctx.strokeRect(x, y, btnW, btnH);

   
        ctx.fillStyle = canAfford ? '#fff' : '#666';
        ctx.font = "bold 18px Arial";
        ctx.textAlign = "left";
        ctx.fillText(item.name, x + 15, y + 30);
       
        ctx.fillStyle = canAfford ? '#ffd700' : '#ff4444';
        ctx.font = "14px Arial";
        ctx.fillText(`$ ${item.cost}`, x + 15, y + 55);

        ctx.fillStyle = '#aaa';
        ctx.font = "12px Arial";
        ctx.fillText(item.desc, x + 80, y + 55);
    });
}

function checkShopClick(mx, my) {
    const p = heroes.find(h => h.isPlayer);
    const shopW = 600, shopH = 500;
    const shopX = (canvas.width - shopW) / 2;
    const shopY = (canvas.height - shopH) / 2;

    SHOP_ITEMS.forEach((item, i) => {
        const col = i % 2;
        const row = Math.floor(i / 2);
        const btnW = 260, btnH = 80;
        const gap = 20;
        const x = shopX + gap + col * (btnW + gap);
        const y = shopY + 80 + row * (btnH + gap);

        if (mx > x && mx < x + btnW && my > y && my < y + btnH) {
            if (p.gold >= item.cost) {
                p.gold -= item.cost;
               
                if (item.atk) p.atk += item.atk;
                if (item.hp) { p.maxHp += item.hp; p.hp += item.hp; }
               
                showPurchaseTip(`Purchase Succeed: ${item.name}`, "#20ab45");
            } else {
                showPurchaseTip("Not Enough GOLDÔºÅ", "#cc2b2b");
            }
        }
    });
}



function showPurchaseTip(text, color = "#6f70ab") {
    floatingTexts.push({
        text: text,
        x: canvas.width / 2,    
        y: canvas.height / 2,    
        alpha: 1.0,            
        life: 60                
    });
}


function drawScoreboardUI() {
    const bw = 1000, bh = 600;
    const bx = (canvas.width - bw) / 2, by = (canvas.height - bh) / 2;
    const centerX = canvas.width / 2;
   
    ctx.save();
   
   
    ctx.fillStyle = 'rgba(10, 20, 30, 0.95)';
    ctx.shadowBlur = 50;
    ctx.shadowColor = 'black';
    ctx.fillRect(bx, by, bw, bh);
   
 
    ctx.strokeStyle = '#c8aa6e';
    ctx.lineWidth = 3;
    ctx.strokeRect(bx, by, bw, bh);
   

    const blueKills = heroes.filter(h => h.team === 'blue').reduce((sum, h) => sum + h.kills, 0);
    const redKills = heroes.filter(h => h.team === 'red').reduce((sum, h) => sum + h.kills, 0);
   
   
    ctx.font = "bold 42px 'Courier New', monospace";
    ctx.textAlign = "center";
   
 
    ctx.fillStyle = "#00d2ff";
    ctx.fillText(blueKills, centerX - 80, by + 60);

    ctx.fillStyle = "#fff";
    ctx.font = "italic 24px Arial";
    ctx.fillText("VS", centerX, by + 55);
   
    ctx.fillStyle = "#ff4444";
    ctx.font = "bold 42px 'Courier New', monospace";
    ctx.fillText(redKills, centerX + 80, by + 60);

 
    const renderTeam = (isRed) => {
        const team = heroes.filter(h => h.team === (isRed ? 'red' : 'blue'));
        const startX = isRed ? centerX + 20 : bx + 20;
        const listWidth = 460;
       
       
        ctx.fillStyle = isRed ? "rgba(255, 68, 68, 0.2)" : "rgba(0, 210, 255, 0.2)";
        ctx.fillRect(startX, by + 100, listWidth, 40);
       
        ctx.textAlign = "left";
        ctx.fillStyle = isRed ? "#ff8888" : "#88d2ff";
        ctx.font = "bold 18px Arial";
        ctx.fillText(isRed ? "RED TEAM (Chaos)" : "BLUE TEAM (Order)", startX + 15, by + 127);
        ctx.fillText("K/D/A", startX + 220, by + 127);
        ctx.fillText("GOLD", startX + 350, by + 127);

       
        team.forEach((h, i) => {
            const ry = by + 160 + i * 70;
           
           
            ctx.fillStyle = h.isPlayer ? 'rgba(200, 170, 110, 0.15)' : 'rgba(255, 255, 255, 0.03)';
            ctx.roundRect(startX, ry, listWidth, 60, 5);
            ctx.fill();
            if(h.isPlayer) {
                ctx.strokeStyle = '#c8aa6e';
                ctx.lineWidth = 1;
                ctx.strokeRect(startX, ry, listWidth, 60);
            }

           
            ctx.fillStyle = h.isDead ? "#555" : (isRed ? "#ff4444" : "#00d2ff");
            ctx.beginPath();
            ctx.arc(startX + 40, ry + 30, 20, 0, Math.PI * 2);
            ctx.fill();

     
            ctx.fillStyle = "#fff";
            ctx.font = "bold 16px Arial";
            ctx.fillText(h.role.toUpperCase(), startX + 75, ry + 25);
            ctx.fillStyle = "#aaa";
            ctx.font = "12px Arial";
            ctx.fillText("Lv." + h.level, startX + 75, ry + 45);

         
            ctx.textAlign = "center";
            ctx.fillStyle = "#fff";
            ctx.font = "bold 18px 'Courier New'";
            ctx.fillText(`${h.kills}/${h.deaths}/${h.assists}`, startX + 250, ry + 37);

   
            ctx.textAlign = "right";
            ctx.fillStyle = "gold";
            ctx.fillText(Math.floor(h.totalGold || 0), startX + 440, ry + 37);
            ctx.textAlign = "left";
        });
    };



   renderTeam(false);
    renderTeam(true);  
    ctx.restore();


}   // function render ends



function applyFogOfWar(player) {
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
   
    let fog = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, player.vision * 0.5,
        canvas.width/2, canvas.height/2, player.vision
    );
    fog.addColorStop(0, 'rgba(0,0,0,0)');
    fog.addColorStop(1, 'rgba(0,0,0,0.7)');

    ctx.fillStyle = fog;
    ctx.fillRect(0, 0, canvas.width, canvas.height);


ctx.strokeStyle = '#00f2ff';
ctx.lineWidth = 20;        
ctx.strokeRect(0, 0, WORLD_SIZE, WORLD_SIZE);


ctx.shadowBlur = 15;
ctx.shadowColor = '#00f2ff';
ctx.strokeRect(0, 0, WORLD_SIZE, WORLD_SIZE);
ctx.shadowBlur = 0;

    ctx.restore();
}



function drawUI(now) {
    const p = heroes.find(h => h.isPlayer);
    if (p.isDead) {
        let remaining = Math.max(0, (p.respawnAt - now) / 1000);
        ctx.save(); ctx.textAlign = "center"; ctx.shadowColor = "black"; ctx.shadowBlur = 10; ctx.lineWidth = 5; ctx.font = "bold 54px Arial";      
        ctx.strokeStyle = "black"; ctx.strokeText("RESPAWNING...", canvas.width / 2, canvas.height / 2 - 40); ctx.fillStyle = "#ffcc00";  
        ctx.fillText("RESPAWNING...", canvas.width / 2, canvas.height / 2 - 40); ctx.font = "bold 86px Arial"; ctx.strokeStyle = "black";
        ctx.strokeText(remaining.toFixed(1) + "s", canvas.width / 2, canvas.height / 2 + 60); ctx.fillStyle = "#ff3300";
        ctx.fillText(remaining.toFixed(1) + "s", canvas.width / 2, canvas.height / 2 + 60); ctx.restore(); ctx.textAlign = "left";
    }
    ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(20, 20, 320, 190);
    ctx.fillStyle = '#83d46a'; ctx.font = "bold 18px Arial"; ctx.fillText(`Level: ${p.level} | Position: ${p.role.toUpperCase()}`, 40, 50);
    ctx.fillStyle = '#f7c719'; ctx.fillText(`GOLD: ${p.gold.toFixed(1)} | ATK: ${p.atk}`, 40, 80);

    drawHPBar(40, 100, 200, 8, p.exp, p.level*200+100, '#00bbff');

    let cdPerc = p.skillCD / p.skillMaxCD;
    ctx.fillStyle = '#222'; ctx.fillRect(40, 120, 200, 20); ctx.fillStyle = cdPerc > 0 ? '#555' : '#e86bc7'; ctx.fillRect(40, 120, 200*(1-cdPerc), 20);
    ctx.fillStyle = '#fff'; ctx.font = "12px Arial"; ctx.fillText(cdPerc>0?`ULTIMATE...` : "ULTIMATE READY(L)", 50, 135);


    let cd2Perc = p.skill2CD / p.skill2MaxCD;
    ctx.fillStyle = '#222';
    ctx.fillRect(40, 145, 200, 15);
    ctx.fillStyle = cd2Perc > 0 ? '#444' : '#6b77e8';
    ctx.fillRect(40, 145, 200 * (1 - cd2Perc), 15);
    ctx.fillStyle = '#fff';
    ctx.font = "10px Arial";
    ctx.fillText(cd2Perc > 0 ? "DASH ON COOLDOWN..." : "DASH READY(I)", 50, 156);


    ctx.fillText("P: SHOP | B: RECALL | J: ATTACK TOWER | K: ATTACK UNIT", 40, 171);
    ctx.fillStyle = "cyan"; ctx.fillText(`SPD: ${p.speed} | RANGE: ${p.range}`, 40, 185);

  if (p.isRecalling) {
    let remaining = (p.recallEndAt - now) / 1000;
    let progress = 1 - (remaining / (p.recallMaxTime / 1000));
   
   
    let bw = 300, bh = 20, bx = canvas.width/2 - 150, by = canvas.height - 150;
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(bx, by, bw, bh);
   
 
    ctx.fillStyle = '#00f2ff';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#00f2ff';
    ctx.fillRect(bx, by, bw * Math.max(0, progress), bh);
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#fff';
    ctx.textAlign = "center";
    ctx.font = "bold 16px Arial";
    ctx.fillText(`RECALLING... ${remaining.toFixed(1)}s`, canvas.width/2, by - 10);
    ctx.textAlign = "left";
}



    const ms = 180, mx = canvas.width - 200, my = canvas.height - 200;
    ctx.fillStyle='rgba(0,0,0,0.85)'; ctx.fillRect(mx, my, ms, ms);

    towers.forEach(t => { drawHPBar(
    t.x - 40,
    t.y - (t.lane === 'main' ? 75 : 60),
    80, 8,
    t.hp,
    t.maxHp,
    t.displayHp,
    t.team === 'blue' ? '#00ff44' : '#ff4444'
);

if(t.hp > 0) { ctx.fillStyle = t.team==='blue'?'#00ff44':'#ff4444'; ctx.fillRect(mx+(t.x/4000)*ms-3, my+(t.y/4000)*ms-3, 6, 6); }});

    jungles.forEach(j => { if(!j.isDead) { ctx.fillStyle = '#ffaa00'; ctx.fillRect(mx+(j.x/4000)*ms-2, my+(j.y/4000)*ms-2, 4, 4); }});
    minions.concat(heroes).forEach(o => { if((o.hp > 0 || !o.isDead) && isVisibleToBlue(o)) { ctx.fillStyle = o.team==='blue'?'#00ff44':'#ff4444'; ctx.beginPath(); ctx.arc(mx+(o.x/4000)*ms, my+(o.y/4000)*ms, o.radius?5:2, 0, Math.PI*2); ctx.fill(); }});
    }


const keyStates = {};

window.onkeydown = (e) => {
    const key = e.key.toLowerCase();
 
if (key === 'l') {
        useUltimate();
    }

    if (keyStates[key]) return;
    keyStates[key] = true;

 
    if (key === 'p') {
        toggleShop();
    }
   
    if (key === 'tab') {
        showScoreboard = true;
    }
};

canvas.addEventListener('mousedown', (e) => {
    if (!isShopOpen) return;


    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;


    checkShopClick(mouseX, mouseY);
});

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
 
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
});



window.onkeyup = (e) => {
    const key = e.key.toLowerCase();
    keyStates[key] = false;
   
    if (key === 'tab') {
        showScoreboard = false;
    }
};


window.onkeyup = (e) => keys[e.key.toLowerCase()] = false;

setInterval(spawnMinions, 20000);
function loop() { update(); render(); requestAnimationFrame(loop); }

</script>
</body>
</html>





